# ğŸ”§ åç«¯å¼€å‘

æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç» MDtranslator åç«¯çš„æ¶æ„è®¾è®¡ã€æ¨¡å—å®ç°å’Œå¼€å‘æŒ‡å—ã€‚

## ç›®å½•

- [æŠ€æœ¯æ ˆ](#æŠ€æœ¯æ ˆ)
- [é¡¹ç›®ç»“æ„](#é¡¹ç›®ç»“æ„)
- [æ ¸å¿ƒæ¨¡å—](#æ ¸å¿ƒæ¨¡å—)
- [API è®¾è®¡](#api-è®¾è®¡)
- [WebSocket é€šä¿¡](#websocket-é€šä¿¡)
- [å­˜å‚¨å±‚](#å­˜å‚¨å±‚)
- [é…ç½®ç®¡ç†](#é…ç½®ç®¡ç†)
- [å¼€å‘æŒ‡å—](#å¼€å‘æŒ‡å—)

---

## æŠ€æœ¯æ ˆ

| æŠ€æœ¯ | ç‰ˆæœ¬ | ç”¨é€” | æ–‡æ¡£ |
|:---|:---|:---|:---|
| **FastAPI** | 0.100+ | Web æ¡†æ¶ | [fastapi.tiangolo.com](https://fastapi.tiangolo.com/) |
| **Uvicorn** | 0.23+ | ASGI æœåŠ¡å™¨ | [uvicorn.org](https://www.uvicorn.org/) |
| **Python** | 3.11 | è¿è¡Œæ—¶ | [python.org](https://www.python.org/) |
| **aiosqlite** | 0.19+ | å¼‚æ­¥ SQLite | [aiosqlite.omnilib.dev](https://aiosqlite.omnilib.dev/) |
| **OpenAI SDK** | 1.x | LLM è°ƒç”¨ | [openai.com](https://platform.openai.com/docs/) |
| **Pydantic** | 2.x | æ•°æ®éªŒè¯ | [pydantic.dev](https://docs.pydantic.dev/) |
| **markdown-it-py** | 3.x | Markdown è§£æ | [markdown-it-py.readthedocs.io](https://markdown-it-py.readthedocs.io/) |

---

## é¡¹ç›®ç»“æ„

```
backend/
â”œâ”€â”€ main.py                     # FastAPI åº”ç”¨å…¥å£
â”œâ”€â”€ persistent_storage.py       # SQLite å­˜å‚¨å±‚
â”œâ”€â”€ markdown_utils.py           # Markdown å¤„ç†å·¥å…·
â”œâ”€â”€ requirements.txt            # Python ä¾èµ–
â”‚
â”œâ”€â”€ routers/                    # API è·¯ç”±æ¨¡å—
â”‚   â””â”€â”€ translate.py           # ç¿»è¯‘ç›¸å…³ API
â”‚
â”œâ”€â”€ prompts/                    # æç¤ºè¯æ¨¡æ¿
â”‚   â””â”€â”€ system_prompt.txt      # ç³»ç»Ÿæç¤ºè¯
â”‚
â””â”€â”€ data/                       # æ•°æ®ç›®å½•ï¼ˆè‡ªåŠ¨åˆ›å»ºï¼‰
    â””â”€â”€ mdtranslator.db        # SQLite æ•°æ®åº“
```

---

## æ ¸å¿ƒæ¨¡å—

### main.py - åº”ç”¨å…¥å£

FastAPI åº”ç”¨çš„ä¸»å…¥å£ï¼Œè´Ÿè´£åˆå§‹åŒ–å’Œé…ç½®ã€‚

```python
# backend/main.py
from contextlib import asynccontextmanager
from fastapi import FastAPI, WebSocket
from fastapi.middleware.cors import CORSMiddleware
from dotenv import load_dotenv
import os
from pathlib import Path

from routers import translate
from routers.translate import manager, websocket_translate_handler

# åŠ è½½ç¯å¢ƒå˜é‡
env_path = Path(__file__).resolve().parent.parent / '.env'
load_dotenv(dotenv_path=env_path)

@asynccontextmanager
async def lifespan(app: FastAPI):
    """åº”ç”¨ç”Ÿå‘½å‘¨æœŸç®¡ç†"""
    # å¯åŠ¨æ—¶
    print("MDTranslator Backend starting...")
    print(f"QWEN_API_KEY configured: {'Yes' if os.getenv('QWEN_API_KEY') else 'No'}")
    yield
    # å…³é—­æ—¶
    print("MDTranslator Backend shutting down...")

app = FastAPI(title="MDTranslator Backend", lifespan=lifespan)

# CORS é…ç½®
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# æ³¨å†Œè·¯ç”±
app.include_router(translate.router)

# WebSocket ç«¯ç‚¹
@app.websocket("/ws/translate/{doc_id}")
async def websocket_endpoint(websocket: WebSocket, doc_id: str):
    await websocket_translate_handler(websocket, doc_id)

@app.get("/")
async def root():
    return {"message": "MDTranslator Backend Running"}
```

**å…³é”®ç‚¹ï¼š**
- ä½¿ç”¨ `lifespan` ç®¡ç†åº”ç”¨ç”Ÿå‘½å‘¨æœŸ
- ç¯å¢ƒå˜é‡ä»é¡¹ç›®æ ¹ç›®å½•çš„ `.env` åŠ è½½
- WebSocket ç«¯ç‚¹ç›´æ¥æ³¨å†Œåœ¨ä¸»åº”ç”¨ä¸Š
- **ä½¿ç”¨ç»å¯¹å¯¼å…¥**ï¼ˆ`from routers import translate`ï¼‰ï¼Œä¸æ˜¯ç›¸å¯¹å¯¼å…¥

---

### routers/translate.py - ç¿»è¯‘è·¯ç”±

æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ï¼ŒåŒ…å«ç¿»è¯‘ API å’Œ WebSocket å¤„ç†ã€‚

```python
# backend/routers/translate.py
import os
import asyncio
import uuid
from fastapi import APIRouter, HTTPException, WebSocket
from pydantic import BaseModel
from openai import AsyncOpenAI

from persistent_storage import store as document_store  # ç»å¯¹å¯¼å…¥
from markdown_utils import split_into_chunks

router = APIRouter()

# --- è¯·æ±‚/å“åº”æ¨¡å‹ ---
class TranslateRequest(BaseModel):
    content: str
    title: Optional[str] = None

class SettingsRequest(BaseModel):
    settings: Dict[str, Any]

# --- WebSocket è¿æ¥ç®¡ç† ---
class ConnectionManager:
    def __init__(self):
        self.active_connections: Dict[str, WebSocket] = {}

    async def connect(self, doc_id: str, websocket: WebSocket):
        await websocket.accept()
        self.active_connections[doc_id] = websocket

    def disconnect(self, doc_id: str):
        self.active_connections.pop(doc_id, None)

    async def send_message(self, doc_id: str, message: dict):
        if doc_id in self.active_connections:
            await self.active_connections[doc_id].send_json(message)

manager = ConnectionManager()
```

#### ç¿»è¯‘å¹¶å‘æ§åˆ¶

ä½¿ç”¨ `asyncio.Semaphore` é™åˆ¶å¹¶å‘ç¿»è¯‘ä»»åŠ¡æ•°ï¼š

```python
CONCURRENCY_LIMIT = 5
semaphore = asyncio.Semaphore(CONCURRENCY_LIMIT)

async def translate_chunk_task(doc_id: str, chunk: dict, client: AsyncOpenAI, ...):
    async with semaphore:  # å¹¶å‘æ§åˆ¶
        chunk_index = chunk["chunk_index"]
        
        # é€šçŸ¥å‰ç«¯å¼€å§‹å¤„ç†
        await manager.send_message(doc_id, {
            "type": "chunk_update",
            "chunkIndex": chunk_index,
            "data": {"status": "processing", "translatedText": ""}
        })
        
        try:
            # è°ƒç”¨ LLM è¿›è¡Œç¿»è¯‘ï¼ˆæµå¼ï¼‰
            stream = await client.chat.completions.create(
                model=os.getenv("QWEN_MODEL_NAME", "qwen-flash"),
                messages=[
                    {"role": "system", "content": SYSTEM_PROMPT},
                    {"role": "user", "content": user_content}
                ],
                stream=True,
                temperature=0.1,
            )
            
            full_text = ""
            async for part in stream:
                content = part.choices[0].delta.content or ""
                if content:
                    full_text += content
                    # å®æ—¶æ¨é€ç¿»è¯‘å†…å®¹
                    await manager.send_message(doc_id, {
                        "type": "chunk_update",
                        "chunkIndex": chunk_index,
                        "data": {"translatedText": full_text}
                    })
            
            # ä¿å­˜åˆ°æ•°æ®åº“
            await document_store.update_chunk(doc_id, chunk_index, full_text, "completed")
            
        except Exception as e:
            print(f"Error translating chunk {chunk_index}: {e}")
            await document_store.update_chunk(doc_id, chunk_index, "", "error")
```

---

### markdown_utils.py - Markdown å·¥å…·

è´Ÿè´£ Markdown æ–‡æ¡£çš„åˆ†å—å¤„ç†ã€‚

```python
# backend/markdown_utils.py
from markdown_it import MarkdownIt
from typing import List, Dict

md = MarkdownIt("commonmark")

def split_into_chunks(content: str, num_chunks: int = 3) -> List[Dict]:
    """
    å°† Markdown å†…å®¹åˆ†å‰²æˆ N ä¸ªå—ã€‚
    åŸºäº H1/H2 æ ‡é¢˜è¾¹ç•Œè¿›è¡Œåˆ†å‰²ï¼Œä¿æŒæ–‡æ¡£ç»“æ„å®Œæ•´æ€§ã€‚
    
    Args:
        content: Markdown å†…å®¹
        num_chunks: ç›®æ ‡åˆ†å—æ•°ï¼ˆé»˜è®¤ 3ï¼‰
    
    Returns:
        åˆ†å—å­—å…¸åˆ—è¡¨
    """
    if not content:
        return []
    
    num_chunks = max(1, num_chunks)
    tokens = md.parse(content)
    lines = content.splitlines(keepends=True)
    total_lines = len(lines)
    
    # æŸ¥æ‰¾æ‰€æœ‰æ ‡é¢˜ä½ç½®ä½œä¸ºåˆ†å‰²ç‚¹
    split_points = [0]
    for token in tokens:
        if (token.level == 0 and token.map and 
            token.type == 'heading_open' and 
            token.tag in ['h1', 'h2']):
            start_line = token.map[0]
            if start_line > 0:
                split_points.append(start_line)
    
    split_points.append(total_lines)
    split_points = sorted(set(split_points))
    
    # æ ¹æ®åˆ†å‰²ç‚¹ç”Ÿæˆåˆ†å—èŒƒå›´
    # ... è¯¦ç»†åˆ†å—é€»è¾‘ ...
    
    # æ„å»ºåˆ†å—æ•°æ®
    chunks = []
    for i, (start, end) in enumerate(chunk_ranges):
        chunk_content = "".join(lines[start:end])
        if chunk_content.strip():
            chunks.append({
                "chunk_index": len(chunks),
                "raw_text": chunk_content,
                "translated_text": None,
                "status": "pending",
                "start_line": start,
                "end_line": end
            })
    
    return chunks
```

**åˆ†å—ç­–ç•¥ï¼š**

| ç­–ç•¥ | æè¿° |
|:---|:---|
| **æ ‡é¢˜è¾¹ç•Œ** | ä¼˜å…ˆåœ¨ H1/H2 æ ‡é¢˜å¤„åˆ†å‰² |
| **å‡åŒ€åˆ†å¸ƒ** | å½“æ ‡é¢˜æ•° > ç›®æ ‡åˆ†å—æ•°æ—¶ï¼Œé€‰æ‹©æœ€æ¥è¿‘å‡åŒ€åˆ†å¸ƒçš„æ ‡é¢˜ä½ç½® |
| **å®Œæ•´æ€§** | ä¿æŒä»£ç å—ã€åˆ—è¡¨ç­‰ç»“æ„å®Œæ•´ |

---

### persistent_storage.py - å­˜å‚¨å±‚

åŸºäº SQLite çš„å¼‚æ­¥å­˜å‚¨å®ç°ã€‚

```python
# backend/persistent_storage.py
import json
import aiosqlite
from typing import Dict, Any, Optional, List
from datetime import datetime
from pathlib import Path

# æ•°æ®åº“è·¯å¾„
DATA_DIR = Path(__file__).resolve().parent / "data"
DATA_DIR.mkdir(exist_ok=True)
DB_PATH = DATA_DIR / "mdtranslator.db"

class PersistentStore:
    """å¼‚æ­¥ SQLite å­˜å‚¨æ¥å£"""
    
    def __init__(self):
        self._initialized = False
    
    def _get_connection(self):
        """è·å–æ•°æ®åº“è¿æ¥ï¼ˆæ¯æ¬¡æ–°å»ºï¼Œé¿å…çº¿ç¨‹é—®é¢˜ï¼‰"""
        return aiosqlite.connect(DB_PATH)
    
    async def _ensure_initialized(self, conn: aiosqlite.Connection):
        """ç¡®ä¿è¡¨ç»“æ„å­˜åœ¨"""
        if not self._initialized:
            conn.row_factory = aiosqlite.Row
            await conn.execute(CREATE_DOCUMENTS_TABLE)
            await conn.execute(CREATE_SETTINGS_TABLE)
            await conn.execute(CREATE_INDEX)
            await conn.commit()
            self._initialized = True
    
    async def create_document(self, doc_id: str, title: str, 
                              original_content: str, chunks_data: list) -> Dict:
        """åˆ›å»ºæ–°æ–‡æ¡£"""
        now = datetime.now().isoformat()
        chunks_json = json.dumps(chunks_data, ensure_ascii=False)
        
        async with self._get_connection() as conn:
            conn.row_factory = aiosqlite.Row
            await self._ensure_initialized(conn)
            await conn.execute(
                """INSERT INTO documents 
                   (id, title, original_content, chunks_data, status, created_at, updated_at)
                   VALUES (?, ?, ?, ?, 'processing', ?, ?)""",
                (doc_id, title, original_content, chunks_json, now, now)
            )
            await conn.commit()
        
        return { ... }
    
    async def get_document(self, doc_id: str) -> Optional[Dict]:
        """è·å–å•ä¸ªæ–‡æ¡£"""
        async with self._get_connection() as conn:
            conn.row_factory = aiosqlite.Row
            await self._ensure_initialized(conn)
            cursor = await conn.execute(
                "SELECT * FROM documents WHERE id = ?", (doc_id,)
            )
            row = await cursor.fetchone()
            
            if not row:
                return None
            
            return {
                "id": row["id"],
                "title": row["title"],
                "original_content": row["original_content"],
                "translated_content": row["translated_content"] or "",
                "chunks_data": json.loads(row["chunks_data"] or "[]"),
                "status": row["status"],
                "created_at": row["created_at"],
                "updated_at": row["updated_at"],
                "is_translated": bool(row["translated_content"])
            }
    
    # ... å…¶ä»–æ–¹æ³• ...

# å¯¼å‡ºå•ä¾‹
store = PersistentStore()
```

**å…³é”®è®¾è®¡ï¼š**

| è¦ç‚¹ | è¯´æ˜ |
|:---|:---|
| **è¿æ¥ç®¡ç†** | æ¯æ¬¡æ“ä½œè·å–æ–°è¿æ¥ï¼Œé¿å… "threads can only be started once" é”™è¯¯ |
| **Row Factory** | ä½¿ç”¨ `aiosqlite.Row` æ”¯æŒå­—å…¸å¼è®¿é—® |
| **JSON åºåˆ—åŒ–** | `chunks_data` å­˜å‚¨ä¸º JSON å­—ç¬¦ä¸² |
| **å•ä¾‹æ¨¡å¼** | å¯¼å‡º `store` å®ä¾‹ä¾›å…¶ä»–æ¨¡å—ä½¿ç”¨ |

---

## API è®¾è®¡

### ç¿»è¯‘ç›¸å…³

| ç«¯ç‚¹ | æ–¹æ³• | è¯´æ˜ |
|:---|:---|:---|
| `/api/translate` | POST | åˆ›å»ºç¿»è¯‘ä»»åŠ¡ |
| `/ws/translate/{doc_id}` | WebSocket | å®æ—¶ç¿»è¯‘æµ |

### æ–‡æ¡£ç®¡ç†

| ç«¯ç‚¹ | æ–¹æ³• | è¯´æ˜ |
|:---|:---|:---|
| `/api/documents` | GET | è·å–æ–‡æ¡£åˆ—è¡¨ |
| `/api/documents/{id}` | GET | è·å–å•ä¸ªæ–‡æ¡£ |
| `/api/documents/{id}` | DELETE | åˆ é™¤æ–‡æ¡£ |

### è®¾ç½®ç®¡ç†

| ç«¯ç‚¹ | æ–¹æ³• | è¯´æ˜ |
|:---|:---|:---|
| `/api/settings` | GET | è·å–è®¾ç½® |
| `/api/settings` | POST | ä¿å­˜è®¾ç½® |

---

## WebSocket é€šä¿¡

### è¿æ¥æµç¨‹

```
1. å®¢æˆ·ç«¯ POST /api/translate åˆ›å»ºä»»åŠ¡
   â†“ è¿”å› docId
2. å®¢æˆ·ç«¯è¿æ¥ ws://host/ws/translate/{docId}
   â†“ 
3. æœåŠ¡ç«¯å¼€å§‹ç¿»è¯‘ï¼Œé€å—æ¨é€ç»“æœ
   â†“
4. ç¿»è¯‘å®Œæˆï¼Œå‘é€ complete æ¶ˆæ¯
```

### æ¶ˆæ¯ç±»å‹

**chunk_update** - åˆ†å—æ›´æ–°ï¼š

```json
{
  "type": "chunk_update",
  "chunkIndex": 0,
  "data": {
    "status": "processing | completed | error",
    "translatedText": "ç¿»è¯‘å†…å®¹..."
  }
}
```

**complete** - ç¿»è¯‘å®Œæˆï¼š

```json
{
  "type": "complete"
}
```

---

## å­˜å‚¨å±‚

### æ•°æ®åº“è¡¨ç»“æ„

**documents è¡¨ï¼š**

```sql
CREATE TABLE IF NOT EXISTS documents (
    id TEXT PRIMARY KEY,
    title TEXT,
    original_content TEXT,
    translated_content TEXT DEFAULT '',
    chunks_data TEXT DEFAULT '[]',
    status TEXT DEFAULT 'pending',
    created_at TEXT,
    updated_at TEXT
);

CREATE INDEX IF NOT EXISTS idx_documents_updated_at 
ON documents(updated_at DESC);
```

**settings è¡¨ï¼š**

```sql
CREATE TABLE IF NOT EXISTS settings (
    key TEXT PRIMARY KEY,
    value TEXT
);
```

---

## é…ç½®ç®¡ç†

### ç¯å¢ƒå˜é‡

åœ¨é¡¹ç›®æ ¹ç›®å½•åˆ›å»º `.env` æ–‡ä»¶ï¼š

```env
# LLM é…ç½®
QWEN_API_KEY=your_api_key_here
QWEN_API_URL=https://dashscope.aliyuncs.com/compatible-mode/v1
QWEN_MODEL_NAME=qwen-flash
```

### æ”¯æŒçš„é…ç½®é¡¹

| å˜é‡ | è¯´æ˜ | é»˜è®¤å€¼ |
|:---|:---|:---|
| `QWEN_API_KEY` | API å¯†é’¥ | - |
| `QWEN_API_URL` | API åœ°å€ | `https://dashscope.aliyuncs.com/compatible-mode/v1` |
| `QWEN_MODEL_NAME` | æ¨¡å‹åç§° | `qwen-flash` |

---

## å¼€å‘æŒ‡å—

### æ·»åŠ æ–°è·¯ç”±

1. åˆ›å»ºè·¯ç”±æ–‡ä»¶ï¼š

```python
# backend/routers/my_router.py
from fastapi import APIRouter

router = APIRouter()

@router.get("/api/my-endpoint")
async def my_endpoint():
    return {"message": "Hello"}
```

2. åœ¨ `main.py` ä¸­æ³¨å†Œï¼š

```python
# backend/main.py
from routers import translate, my_router

app.include_router(translate.router)
app.include_router(my_router.router)
```

### æ·»åŠ æ–°çš„æ•°æ®åº“æ–¹æ³•

åœ¨ `persistent_storage.py` ä¸­æ·»åŠ ï¼š

```python
async def my_new_method(self, param: str) -> Optional[Dict]:
    """æ–°çš„æ•°æ®åº“æ“ä½œ"""
    async with self._get_connection() as conn:
        conn.row_factory = aiosqlite.Row
        await self._ensure_initialized(conn)
        # æ‰§è¡Œ SQL æ“ä½œ
        cursor = await conn.execute("SELECT * FROM ...", (param,))
        row = await cursor.fetchone()
        return dict(row) if row else None
```

### è°ƒè¯•æŠ€å·§

1. **å¯åŠ¨è°ƒè¯•æ¨¡å¼**ï¼š

```bash
uvicorn main:app --reload --log-level debug
```

2. **æŸ¥çœ‹ API æ–‡æ¡£**ï¼š

è®¿é—® `http://127.0.0.1:8000/docs` æŸ¥çœ‹è‡ªåŠ¨ç”Ÿæˆçš„ Swagger æ–‡æ¡£ã€‚

3. **æ£€æŸ¥æ•°æ®åº“**ï¼š

```bash
sqlite3 backend/data/mdtranslator.db
.tables
SELECT * FROM documents;
```

### å¸¸è§é—®é¢˜

**Q: å¯¼å…¥é”™è¯¯ `ImportError: attempted relative import`**

A: ä½¿ç”¨ç»å¯¹å¯¼å…¥è€Œä¸æ˜¯ç›¸å¯¹å¯¼å…¥ï¼š

```python
# âŒ é”™è¯¯
from .persistent_storage import store

# âœ… æ­£ç¡®
from persistent_storage import store
```

**Q: aiosqlite æŠ¥é”™ "threads can only be started once"**

A: ä¸è¦ç¼“å­˜è¿æ¥å¯¹è±¡ï¼Œæ¯æ¬¡æ“ä½œéƒ½è·å–æ–°è¿æ¥ï¼š

```python
# âŒ é”™è¯¯ï¼šç¼“å­˜è¿æ¥
self._conn = await aiosqlite.connect(DB_PATH)

# âœ… æ­£ç¡®ï¼šæ¯æ¬¡æ–°å»ºè¿æ¥
async with aiosqlite.connect(DB_PATH) as conn:
    # æ“ä½œ...
```

---

## ä¸‹ä¸€æ­¥

- ğŸ”„ [æ•°æ®æµè®¾è®¡](./05-æ•°æ®æµè®¾è®¡.md) - äº†è§£å®Œæ•´æ•°æ®æµ
- ğŸ“¡ [API å‚è€ƒ](./06-APIå‚è€ƒ.md) - å®Œæ•´ API æ–‡æ¡£
- ğŸ› ï¸ [äºŒæ¬¡å¼€å‘](./07-äºŒæ¬¡å¼€å‘.md) - æ‰©å±•æŒ‡å—
