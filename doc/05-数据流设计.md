# 🔄 数据流设计

本文档详细介绍 MDtranslator 中数据的流转过程，包括 HTTP 请求、WebSocket 通信和状态同步。

## 目录

- [整体数据流](#整体数据流)
- [翻译流程](#翻译流程)
- [文档管理流程](#文档管理流程)
- [状态同步机制](#状态同步机制)
- [错误处理](#错误处理)

---

## 整体数据流

```mermaid
flowchart TB
    subgraph UserInteraction["👤 用户交互"]
        Upload[上传文件]
        Input[输入内容]
        Translate[点击翻译]
        LoadHistory[加载历史]
        ModifySettings[修改设置]
    end

    subgraph Zustand["📦 前端状态管理 (Zustand)"]
        State["rawContent | translatedContent | chunks | isTranslating\ndocId | layoutMode | expandedPanel"]
    end

    subgraph Hooks["🎊 Custom Hooks 层"]
        useTranslation[useTranslation]
        useDocumentHistory[useDocumentHistory]
        useSettings[useSettings]
    end

    subgraph Communication["📡 通信层"]
        HTTP["HTTP 请求\nfetch / API"]
        WS["WebSocket\n实时通信"]
    end

    subgraph NextAPI["Next.js API Routes (代理)"]
        APIDocuments["/api/documents"]
        APITranslate["/api/translate"]
        APISettings["/api/settings"]
    end

    subgraph Backend["FastAPI 后端"]
        Router[路由层]
        Service[服务层]
        Storage[存储层]
    end

    subgraph External["外部服务"]
        SQLite[("🗄️ SQLite 数据库\n本地持久化")]
        LLM["🤖 LLM API 调用\n流式翻译"]
    end

    UserInteraction --> Zustand
    Zustand --> Hooks
    Hooks --> HTTP
    Hooks --> WS
    HTTP --> NextAPI
    WS --> NextAPI
    NextAPI --> Backend
    Router --> Service --> Storage
    Backend --> SQLite
    Backend --> LLM
```

---

## 翻译流程

翻译是最核心的功能，涉及多个步骤和组件协作。

### 1. 创建翻译任务

```mermaid
flowchart TB
    A["👆 用户点击'翻译'按钮"] --> B
    
    B["1️⃣ useTranslation.startTranslation()\n- setIsTranslating(true)\n- setLayoutMode('quad')"]
    B --> C
    
    C["2️⃣ POST /api/translate\n请求体: { content: '...', title: '...' }"]
    C --> D
    
    D["3️⃣ 后端处理 (routers/translate.py)\n- 生成 UUID 作为 doc_id\n- 调用 split_into_chunks() 分块\n- 存储到 SQLite\n- 返回 { docId, chunks }"]
    D --> E
    
    E["4️⃣ 前端接收响应\n- setDocId(data.docId)\n- setChunks(data.chunks)"]
```

### 2. WebSocket 实时翻译

```mermaid
flowchart TB
    A["5️⃣ 建立 WebSocket 连接\nws://127.0.0.1:8000/ws/translate/{docId}"] --> B
    
    B["6️⃣ 后端 WebSocket Handler\n- 从数据库加载文档\n- 为每个 pending 块创建翻译任务\n- 使用 asyncio.gather() 并行执行"]
    B --> C
    
    subgraph ChunkTranslation["对每个分块..."]
        C["7️⃣ 翻译单个分块 (translate_chunk_task)"]
        C --> C1["a. 发送 status: 'processing'"]
        C1 --> C2["b. 构建提示词（含上下文）"]
        C2 --> C3["c. 调用 LLM API（流式）"]
        C3 --> C4["d. 每收到内容就推送到前端"]
        C4 --> C5["e. 完成后发送 status: 'completed'"]
        C5 --> C6["f. 更新数据库"]
    end
    
    C6 --> D["8️⃣ 前端接收 WebSocket 消息\nws.onmessage 处理 chunk_update"]
    D --> E["9️⃣ Zustand Store 自动组装译文\nupdateChunk 按顺序组装"]
    E --> F["\ud83d\udcfa UI 实时更新\nPreview 组件重新渲染"]
```

### 时序图

```mermaid
sequenceDiagram
    participant U as 👤 User
    participant F as 💻 Frontend
    participant A as 🚀 API
    participant B as ⚙️ Backend
    participant L as 🤖 LLM
    
    U->>F: 点击翻译
    F->>A: POST /api/translate
    A->>B: 转发请求
    B-->>A: { docId, chunks }
    A-->>F: 返回结果
    
    F->>B: WebSocket connect
    
    loop 对每个分块
        B->>L: stream API
        B-->>F: chunk_update (processing)
        loop 流式响应
            L-->>B: stream tokens
            B-->>F: chunk_update (text)
        end
        Note over F: 实时显示
        B-->>F: chunk_update (completed)
    end
    
    B-->>F: { type: "complete" }
```

---

## 文档管理流程

### 加载历史文档

```mermaid
flowchart TB
    A["👆 用户点击'历史记录'"] --> B
    
    B["1️⃣ GET /api/documents\n返回: { documents: [...] }"]
    B --> C
    
    C["2️⃣ 显示历史列表弹窗\n用户选择一个文档"]
    C --> D
    
    D["3️⃣ GET /api/documents/{id}\n返回完整文档数据（含 chunks_data）"]
    D --> E
    
    E["4️⃣ 恢复状态\n- setDocId(doc.id)\n- setRawContent(doc.original_content)\n- setTranslatedContent(doc.translated_content)\n- setChunks(doc.chunks_data)\n- setLayoutMode('quad') // 如果已翻译"]
```

### 删除文档

```mermaid
flowchart LR
    A["👆 用户点击删除按钮"] --> B["DELETE /api/documents/{id}"]
    B --> C["后端从 SQLite 删除记录"]
    C --> D["前端刷新历史列表"]
```

---

## 状态同步机制

### Zustand Store 结构

```typescript
interface DocumentState {
  // 文档数据
  docId: string | null;
  rawContent: string;
  translatedContent: string;
  chunks: TranslationChunk[];
  
  // UI 状态
  isTranslating: boolean;
  layoutMode: 'split' | 'quad';
  expandedPanel: '...' | 'none';
}
```

### 状态更新流向

```mermaid
flowchart TB
    subgraph UpdateSources["📝 状态更新源"]
        S1["1. 用户输入 → setRawContent()"]
        S2["2. WebSocket 消息 → updateChunk()"]
        S3["3. API 响应 → setDocId(), setChunks()"]
        S4["4. 加载历史 → 批量 set 操作"]
    end
    
    subgraph Store["📦 Zustand Store"]
        Notify["自动通知订阅组件"]
    end
    
    subgraph Components["💻 UI 组件"]
        Editor["✏️ Editor\n(原文)"]
        Preview["👁️ Preview\n(译文)"]
        Header["📊 Header\n(进度)"]
    end
    
    UpdateSources --> Store
    Store --> Components
```

### 分块更新与译文组装

```typescript
// 核心逻辑：updateChunk
updateChunk: (index, data) => set((state) => {
  const newChunks = [...state.chunks];
  
  // 1. 找到对应分块
  const chunkIdx = newChunks.findIndex(c => c.chunkIndex === index);
  if (chunkIdx !== -1) {
    newChunks[chunkIdx] = { ...newChunks[chunkIdx], ...data };
  }
  
  // 2. 按顺序排列并组装
  const assembled = newChunks
    .sort((a, b) => a.chunkIndex - b.chunkIndex)
    .map(c => c.translatedText || '')
    .join('');  // 无分隔符，块内已含换行

  return { 
    chunks: newChunks, 
    translatedContent: assembled 
  };
})
```

**关键点：**

| 要点 | 说明 |
|:---|:---|
| 原子更新 | 每次只更新一个分块 |
| 自动组装 | 更新后自动重新组装完整译文 |
| 顺序保证 | 按 `chunkIndex` 排序确保顺序正确 |
| 实时渲染 | React 自动检测变化并重新渲染 |

---

## 错误处理

### 前端错误处理

```typescript
// useTranslation.ts
const startTranslation = useCallback(async () => {
  try {
    const response = await fetch('/api/translate', { ... });
    if (!response.ok) throw new Error('Translation failed');
    
    // WebSocket 错误处理
    ws.onerror = () => setIsTranslating(false);
    ws.onclose = () => setIsTranslating(false);
    
  } catch (e) {
    console.error(e);
    setIsTranslating(false);
  }
}, []);
```

### 后端错误处理

```python
# routers/translate.py
async def translate_chunk_task(...):
    try:
        # 翻译逻辑...
    except Exception as e:
        print(f"Error translating chunk {chunk_index}: {e}")
        
        # 通知前端错误状态
        await manager.send_message(doc_id, {
            "type": "chunk_update",
            "chunkIndex": chunk_index,
            "data": {"status": "error"}
        })
        
        # 更新数据库状态
        await document_store.update_chunk(doc_id, chunk_index, "", "error")
```

### 错误恢复策略

```mermaid
flowchart LR
    subgraph ErrorTypes["⚠️ 错误类型与处理"]
        direction TB
        E1["🌐 网络错误"] --> H1["重试机制 / 提示用户检查网络"]
        E2["⏱️ API 限流"] --> H2["指数退避重试"]
        E3["🤖 LLM 错误"] --> H3["标记分块为 error，允许重新翻译"]
        E4["🗄️ 数据库错误"] --> H4["日志记录，返回友好错误信息"]
        E5["🔌 WebSocket 断开"] --> H5["自动尝试重连 / 提示用户"]
    end
```

---

## 下一步

- 📡 [API 参考](./06-API参考.md) - 完整 API 接口文档
- 🛠️ [二次开发](./07-二次开发.md) - 功能扩展指南
- 🚀 [部署指南](./08-部署指南.md) - 生产环境部署
