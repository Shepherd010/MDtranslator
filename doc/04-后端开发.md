# ğŸ”§ åç«¯å¼€å‘

æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç» MDtranslator åç«¯çš„æ¶æ„è®¾è®¡ã€æ¨¡å—å®ç°å’Œå¼€å‘æŒ‡å—ã€‚

## ç›®å½•

- [æŠ€æœ¯æ ˆ](#æŠ€æœ¯æ ˆ)
- [é¡¹ç›®ç»“æ„](#é¡¹ç›®ç»“æ„)
- [æ ¸å¿ƒæ¨¡å—](#æ ¸å¿ƒæ¨¡å—)
- [API è®¾è®¡](#api-è®¾è®¡)
- [WebSocket é€šä¿¡](#websocket-é€šä¿¡)
- [å­˜å‚¨å±‚](#å­˜å‚¨å±‚)
- [é…ç½®ç®¡ç†](#é…ç½®ç®¡ç†)
- [å¼€å‘æŒ‡å—](#å¼€å‘æŒ‡å—)

---

## æŠ€æœ¯æ ˆ

| æŠ€æœ¯ | ç‰ˆæœ¬ | ç”¨é€” | æ–‡æ¡£ |
|:---|:---|:---|:---|
| **FastAPI** | 0.100+ | Web æ¡†æ¶ | [fastapi.tiangolo.com](https://fastapi.tiangolo.com/) |
| **Uvicorn** | 0.23+ | ASGI æœåŠ¡å™¨ | [uvicorn.org](https://www.uvicorn.org/) |
| **Python** | 3.11 | è¿è¡Œæ—¶ | [python.org](https://www.python.org/) |
| **aiosqlite** | 0.19+ | å¼‚æ­¥ SQLite | [aiosqlite.omnilib.dev](https://aiosqlite.omnilib.dev/) |
| **OpenAI SDK** | 1.x | LLM è°ƒç”¨ | [openai.com](https://platform.openai.com/docs/) |
| **Pydantic** | 2.x | æ•°æ®éªŒè¯ | [pydantic.dev](https://docs.pydantic.dev/) |
| **markdown-it-py** | 3.x | Markdown è§£æ | [markdown-it-py.readthedocs.io](https://markdown-it-py.readthedocs.io/) |

---

## é¡¹ç›®ç»“æ„

```
backend/
â”œâ”€â”€ main.py                     # FastAPI åº”ç”¨å…¥å£
â”œâ”€â”€ persistent_storage.py       # SQLite å­˜å‚¨å±‚
â”œâ”€â”€ markdown_utils.py           # Markdown å¤„ç†å·¥å…·
â”œâ”€â”€ requirements.txt            # Python ä¾èµ–
â”‚
â”œâ”€â”€ routers/                    # API è·¯ç”±æ¨¡å—
â”‚   â””â”€â”€ translate.py           # ç¿»è¯‘ç›¸å…³ API
â”‚
â”œâ”€â”€ prompts/                    # æç¤ºè¯æ¨¡æ¿
â”‚   â””â”€â”€ system_prompt.txt      # ç³»ç»Ÿæç¤ºè¯
â”‚
â””â”€â”€ data/                       # æ•°æ®ç›®å½•ï¼ˆè‡ªåŠ¨åˆ›å»ºï¼‰
    â””â”€â”€ mdtranslator.db        # SQLite æ•°æ®åº“
```

---

## æ ¸å¿ƒæ¨¡å—

### main.py - åº”ç”¨å…¥å£

FastAPI åº”ç”¨çš„ä¸»å…¥å£ï¼Œè´Ÿè´£åˆå§‹åŒ–å’Œé…ç½®ã€‚

```python
# backend/main.py
from contextlib import asynccontextmanager
from fastapi import FastAPI, WebSocket
from fastapi.middleware.cors import CORSMiddleware
from dotenv import load_dotenv
import os
from pathlib import Path

from routers import translate
from routers.translate import manager, websocket_translate_handler

# åŠ è½½ç¯å¢ƒå˜é‡
env_path = Path(__file__).resolve().parent.parent / '.env'
load_dotenv(dotenv_path=env_path)

@asynccontextmanager
async def lifespan(app: FastAPI):
    """åº”ç”¨ç”Ÿå‘½å‘¨æœŸç®¡ç†"""
    # å¯åŠ¨æ—¶
    print("MDTranslator Backend starting...")
    print(f"QWEN_API_KEY configured: {'Yes' if os.getenv('QWEN_API_KEY') else 'No'}")
    yield
    # å…³é—­æ—¶
    print("MDTranslator Backend shutting down...")

app = FastAPI(title="MDTranslator Backend", lifespan=lifespan)

# CORS é…ç½®
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# æ³¨å†Œè·¯ç”±
app.include_router(translate.router)

# WebSocket ç«¯ç‚¹
@app.websocket("/ws/translate/{doc_id}")
async def websocket_endpoint(websocket: WebSocket, doc_id: str):
    await websocket_translate_handler(websocket, doc_id)

@app.get("/")
async def root():
    return {"message": "MDTranslator Backend Running"}
```

**å…³é”®ç‚¹ï¼š**
- ä½¿ç”¨ `lifespan` ç®¡ç†åº”ç”¨ç”Ÿå‘½å‘¨æœŸ
- ç¯å¢ƒå˜é‡ä»é¡¹ç›®æ ¹ç›®å½•çš„ `.env` åŠ è½½
- WebSocket ç«¯ç‚¹ç›´æ¥æ³¨å†Œåœ¨ä¸»åº”ç”¨ä¸Š
- **ä½¿ç”¨ç»å¯¹å¯¼å…¥**ï¼ˆ`from routers import translate`ï¼‰ï¼Œä¸æ˜¯ç›¸å¯¹å¯¼å…¥

---

### routers/translate.py - ç¿»è¯‘è·¯ç”±

æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ï¼ŒåŒ…å«ç¿»è¯‘ API å’Œ WebSocket å¤„ç†ã€‚æ”¯æŒ**åŒå‘ç¿»è¯‘**å’Œ**å¤šç”¨æˆ·å¹¶å‘**ã€‚

```python
# backend/routers/translate.py
import os
import asyncio
import uuid
from fastapi import APIRouter, HTTPException, WebSocket
from pydantic import BaseModel
from openai import AsyncOpenAI
import httpx

from persistent_storage import store as document_store
from markdown_utils import split_into_chunks

router = APIRouter()

# å…¨å±€å…±äº«çš„ OpenAI å®¢æˆ·ç«¯ (å¸¦è¿æ¥æ± ï¼Œæ”¯æŒå¤šç”¨æˆ·å¹¶å‘)
_openai_client: Optional[AsyncOpenAI] = None

def get_openai_client() -> AsyncOpenAI:
    """è·å–å…±äº«çš„ OpenAI å®¢æˆ·ç«¯ï¼ˆå¸¦è¿æ¥æ± ï¼‰"""
    global _openai_client
    if _openai_client is None:
        http_client = httpx.AsyncClient(
            limits=httpx.Limits(max_connections=100, max_keepalive_connections=20),
            timeout=httpx.Timeout(60.0, connect=10.0)
        )
        _openai_client = AsyncOpenAI(
            api_key=os.getenv("QWEN_API_KEY"),
            base_url=os.getenv("QWEN_API_URL"),
            http_client=http_client
        )
    return _openai_client

# --- è¯·æ±‚/å“åº”æ¨¡å‹ ---
class TranslateRequest(BaseModel):
    content: str
    title: Optional[str] = None
    direction: Optional[str] = "en2zh"  # en2zh æˆ– zh2en
```

#### åŒå‘ç¿»è¯‘æ”¯æŒ

ç³»ç»Ÿæ”¯æŒè‹±æ–‡â†’ä¸­æ–‡å’Œä¸­æ–‡â†’è‹±æ–‡ä¸¤ç§ç¿»è¯‘æ–¹å‘ï¼š

```python
def load_system_prompt(direction: str = "en2zh"):
    """æ ¹æ®ç¿»è¯‘æ–¹å‘åŠ è½½å¯¹åº”çš„ System Prompt"""
    if direction == "zh2en":
        prompt_file = "system_prompt_to_C.txt"  # ä¸­æ–‡åˆ°è‹±æ–‡
    else:
        prompt_file = "system_prompt_to_E.txt"  # è‹±æ–‡åˆ°ä¸­æ–‡
    
    prompt_path = os.path.join(os.path.dirname(__file__), "..", "prompts", prompt_file)
    with open(prompt_path, "r", encoding="utf-8") as f:
        return f.read()

def build_user_prompt(content: str, pre_context: str, post_context: str, direction: str):
    """æ„å»ºç”¨æˆ·æç¤ºè¯ï¼Œæ ¹æ®æ–¹å‘è®¾ç½®ç›®æ ‡è¯­è¨€"""
    target_lang = "Chinese" if direction == "en2zh" else "English"
    prompt = f"[Task (Translate to {target_lang})]:\n{content}\n"
    # ... æ·»åŠ ä¸Šä¸‹æ–‡
    return prompt
```

#### å¤šç”¨æˆ·å¹¶å‘è¿æ¥ç®¡ç†

`ConnectionManager` æ”¯æŒå¤šç”¨æˆ·/å¤šæ ‡ç­¾é¡µåŒæ—¶ç¿»è¯‘ï¼š

```python
class ConnectionManager:
    def __init__(self):
        # ç»“æ„: {doc_id: {connection_id: WebSocket}}
        self.active_connections: Dict[str, Dict[str, WebSocket]] = {}
        self.closed_connections: Set[str] = set()  # è·Ÿè¸ªå·²å…³é—­çš„è¿æ¥
        self._lock = asyncio.Lock()

    async def connect(self, doc_id: str, connection_id: str, websocket: WebSocket):
        """è¿æ¥æ–°çš„ WebSocket å®¢æˆ·ç«¯"""
        await websocket.accept()
        async with self._lock:
            if doc_id not in self.active_connections:
                self.active_connections[doc_id] = {}
            self.active_connections[doc_id][connection_id] = websocket
            self.closed_connections.discard(f"{doc_id}/{connection_id}")

    def is_connected(self, doc_id: str, connection_id: str) -> bool:
        """å¿«é€Ÿæ£€æŸ¥è¿æ¥æ˜¯å¦ä»ç„¶æœ‰æ•ˆ"""
        conn_key = f"{doc_id}/{connection_id}"
        if conn_key in self.closed_connections:
            return False
        return (doc_id in self.active_connections and 
                connection_id in self.active_connections[doc_id])

    async def send_message(self, doc_id: str, connection_id: str, message: dict) -> bool:
        """å‘é€æ¶ˆæ¯ç»™ç‰¹å®šè¿æ¥ï¼Œå¤±è´¥æ—¶é™é»˜å¤„ç†"""
        if not self.is_connected(doc_id, connection_id):
            return False
        try:
            ws = self.active_connections.get(doc_id, {}).get(connection_id)
            if ws:
                await ws.send_json(message)
                return True
        except Exception:
            await self.disconnect(doc_id, connection_id)
        return False

manager = ConnectionManager()
```

#### ç¿»è¯‘ä¼šè¯ä¸å¹¶å‘æ§åˆ¶

æ¯ä¸ªç¿»è¯‘ä¼šè¯ç‹¬ç«‹ç®¡ç†è‡ªå·±çš„å¹¶å‘æ§åˆ¶å’Œæ¶ˆæ¯èŠ‚æµï¼š

```python
class TranslationSession:
    """æ¯ä¸ªç¿»è¯‘ä¼šè¯ç‹¬ç«‹ç®¡ç†å¹¶å‘æ§åˆ¶"""
    def __init__(self, doc_id: str, connection_id: str, chunks_per_session: int = 5):
        self.doc_id = doc_id
        self.connection_id = connection_id
        self.semaphore = asyncio.Semaphore(chunks_per_session)  # ç‹¬ç«‹çš„å¹¶å‘æ§åˆ¶
        self.direction = doc_directions.get(doc_id, "en2zh")
        self.cancelled = False
        self._send_interval = 0.05  # æ¶ˆæ¯èŠ‚æµï¼š50ms é—´éš”

    def is_active(self) -> bool:
        """æ£€æŸ¥ä¼šè¯æ˜¯å¦ä»ç„¶æœ‰æ•ˆ"""
        return not self.cancelled and manager.is_connected(self.doc_id, self.connection_id)

    async def send_update(self, message: dict, force: bool = False) -> bool:
        """å‘é€æ›´æ–°ï¼Œå¸¦èŠ‚æµæ§åˆ¶ï¼ˆforce=True ç”¨äºçŠ¶æ€å˜æ›´ï¼‰"""
        if not self.is_active():
            return False
        # èŠ‚æµé€»è¾‘...
        return await manager.send_message(self.doc_id, self.connection_id, message)

    async def translate_chunk(self, chunk: dict, client: AsyncOpenAI, ...):
        """ç¿»è¯‘å•ä¸ª chunkï¼Œä½¿ç”¨ç‹¬ç«‹çš„ Semaphore æ§åˆ¶å¹¶å‘"""
        async with self.semaphore:
            if not self.is_active():
                return
            # ... ç¿»è¯‘é€»è¾‘
```
```

---

### markdown_utils.py - Markdown å·¥å…·

è´Ÿè´£ Markdown æ–‡æ¡£çš„åˆ†å—å¤„ç†ã€‚

```python
# backend/markdown_utils.py
from markdown_it import MarkdownIt
from typing import List, Dict

md = MarkdownIt("commonmark")

def split_into_chunks(content: str, num_chunks: int = 3) -> List[Dict]:
    """
    å°† Markdown å†…å®¹åˆ†å‰²æˆ N ä¸ªå—ã€‚
    åŸºäº H1/H2 æ ‡é¢˜è¾¹ç•Œè¿›è¡Œåˆ†å‰²ï¼Œä¿æŒæ–‡æ¡£ç»“æ„å®Œæ•´æ€§ã€‚
    
    Args:
        content: Markdown å†…å®¹
        num_chunks: ç›®æ ‡åˆ†å—æ•°ï¼ˆé»˜è®¤ 3ï¼‰
    
    Returns:
        åˆ†å—å­—å…¸åˆ—è¡¨
    """
    if not content:
        return []
    
    num_chunks = max(1, num_chunks)
    tokens = md.parse(content)
    lines = content.splitlines(keepends=True)
    total_lines = len(lines)
    
    # æŸ¥æ‰¾æ‰€æœ‰æ ‡é¢˜ä½ç½®ä½œä¸ºåˆ†å‰²ç‚¹
    split_points = [0]
    for token in tokens:
        if (token.level == 0 and token.map and 
            token.type == 'heading_open' and 
            token.tag in ['h1', 'h2']):
            start_line = token.map[0]
            if start_line > 0:
                split_points.append(start_line)
    
    split_points.append(total_lines)
    split_points = sorted(set(split_points))
    
    # æ ¹æ®åˆ†å‰²ç‚¹ç”Ÿæˆåˆ†å—èŒƒå›´
    # ... è¯¦ç»†åˆ†å—é€»è¾‘ ...
    
    # æ„å»ºåˆ†å—æ•°æ®
    chunks = []
    for i, (start, end) in enumerate(chunk_ranges):
        chunk_content = "".join(lines[start:end])
        if chunk_content.strip():
            chunks.append({
                "chunk_index": len(chunks),
                "raw_text": chunk_content,
                "translated_text": None,
                "status": "pending",
                "start_line": start,
                "end_line": end
            })
    
    return chunks
```

**åˆ†å—ç­–ç•¥ï¼š**

| ç­–ç•¥ | æè¿° |
|:---|:---|
| **æ ‡é¢˜è¾¹ç•Œ** | ä¼˜å…ˆåœ¨ H1/H2 æ ‡é¢˜å¤„åˆ†å‰² |
| **å‡åŒ€åˆ†å¸ƒ** | å½“æ ‡é¢˜æ•° > ç›®æ ‡åˆ†å—æ•°æ—¶ï¼Œé€‰æ‹©æœ€æ¥è¿‘å‡åŒ€åˆ†å¸ƒçš„æ ‡é¢˜ä½ç½® |
| **å®Œæ•´æ€§** | ä¿æŒä»£ç å—ã€åˆ—è¡¨ç­‰ç»“æ„å®Œæ•´ |

---

### persistent_storage.py - å­˜å‚¨å±‚

åŸºäº SQLite çš„å¼‚æ­¥å­˜å‚¨å®ç°ã€‚

```python
# backend/persistent_storage.py
import json
import aiosqlite
from typing import Dict, Any, Optional, List
from datetime import datetime
from pathlib import Path

# æ•°æ®åº“è·¯å¾„
DATA_DIR = Path(__file__).resolve().parent / "data"
DATA_DIR.mkdir(exist_ok=True)
DB_PATH = DATA_DIR / "mdtranslator.db"

class PersistentStore:
    """å¼‚æ­¥ SQLite å­˜å‚¨æ¥å£"""
    
    def __init__(self):
        self._initialized = False
    
    def _get_connection(self):
        """è·å–æ•°æ®åº“è¿æ¥ï¼ˆæ¯æ¬¡æ–°å»ºï¼Œé¿å…çº¿ç¨‹é—®é¢˜ï¼‰"""
        return aiosqlite.connect(DB_PATH)
    
    async def _ensure_initialized(self, conn: aiosqlite.Connection):
        """ç¡®ä¿è¡¨ç»“æ„å­˜åœ¨"""
        if not self._initialized:
            conn.row_factory = aiosqlite.Row
            await conn.execute(CREATE_DOCUMENTS_TABLE)
            await conn.execute(CREATE_SETTINGS_TABLE)
            await conn.execute(CREATE_INDEX)
            await conn.commit()
            self._initialized = True
    
    async def create_document(self, doc_id: str, title: str, 
                              original_content: str, chunks_data: list) -> Dict:
        """åˆ›å»ºæ–°æ–‡æ¡£"""
        now = datetime.now().isoformat()
        chunks_json = json.dumps(chunks_data, ensure_ascii=False)
        
        async with self._get_connection() as conn:
            conn.row_factory = aiosqlite.Row
            await self._ensure_initialized(conn)
            await conn.execute(
                """INSERT INTO documents 
                   (id, title, original_content, chunks_data, status, created_at, updated_at)
                   VALUES (?, ?, ?, ?, 'processing', ?, ?)""",
                (doc_id, title, original_content, chunks_json, now, now)
            )
            await conn.commit()
        
        return { ... }
    
    async def get_document(self, doc_id: str) -> Optional[Dict]:
        """è·å–å•ä¸ªæ–‡æ¡£"""
        async with self._get_connection() as conn:
            conn.row_factory = aiosqlite.Row
            await self._ensure_initialized(conn)
            cursor = await conn.execute(
                "SELECT * FROM documents WHERE id = ?", (doc_id,)
            )
            row = await cursor.fetchone()
            
            if not row:
                return None
            
            return {
                "id": row["id"],
                "title": row["title"],
                "original_content": row["original_content"],
                "translated_content": row["translated_content"] or "",
                "chunks_data": json.loads(row["chunks_data"] or "[]"),
                "status": row["status"],
                "created_at": row["created_at"],
                "updated_at": row["updated_at"],
                "is_translated": bool(row["translated_content"])
            }
    
    # ... å…¶ä»–æ–¹æ³• ...

# å¯¼å‡ºå•ä¾‹
store = PersistentStore()
```

**å…³é”®è®¾è®¡ï¼š**

| è¦ç‚¹ | è¯´æ˜ |
|:---|:---|
| **è¿æ¥ç®¡ç†** | æ¯æ¬¡æ“ä½œè·å–æ–°è¿æ¥ï¼Œé¿å… "threads can only be started once" é”™è¯¯ |
| **Row Factory** | ä½¿ç”¨ `aiosqlite.Row` æ”¯æŒå­—å…¸å¼è®¿é—® |
| **JSON åºåˆ—åŒ–** | `chunks_data` å­˜å‚¨ä¸º JSON å­—ç¬¦ä¸² |
| **å•ä¾‹æ¨¡å¼** | å¯¼å‡º `store` å®ä¾‹ä¾›å…¶ä»–æ¨¡å—ä½¿ç”¨ |

---

## API è®¾è®¡

### ç¿»è¯‘ç›¸å…³

| ç«¯ç‚¹ | æ–¹æ³• | è¯´æ˜ |
|:---|:---|:---|
| `/api/translate` | POST | åˆ›å»ºç¿»è¯‘ä»»åŠ¡ |
| `/ws/translate/{doc_id}` | WebSocket | å®æ—¶ç¿»è¯‘æµ |

### æ–‡æ¡£ç®¡ç†

| ç«¯ç‚¹ | æ–¹æ³• | è¯´æ˜ |
|:---|:---|:---|
| `/api/documents` | GET | è·å–æ–‡æ¡£åˆ—è¡¨ |
| `/api/documents/{id}` | GET | è·å–å•ä¸ªæ–‡æ¡£ |
| `/api/documents/{id}` | DELETE | åˆ é™¤æ–‡æ¡£ |

### è®¾ç½®ç®¡ç†

| ç«¯ç‚¹ | æ–¹æ³• | è¯´æ˜ |
|:---|:---|:---|
| `/api/settings` | GET | è·å–è®¾ç½® |
| `/api/settings` | POST | ä¿å­˜è®¾ç½® |

---

## WebSocket é€šä¿¡

### è¿æ¥æµç¨‹

```
1. å®¢æˆ·ç«¯ POST /api/translate åˆ›å»ºä»»åŠ¡
   â†“ è¿”å› docId
2. å®¢æˆ·ç«¯è¿æ¥ ws://host/ws/translate/{docId}
   â†“ 
3. æœåŠ¡ç«¯å¼€å§‹ç¿»è¯‘ï¼Œé€å—æ¨é€ç»“æœ
   â†“
4. ç¿»è¯‘å®Œæˆï¼Œå‘é€ complete æ¶ˆæ¯
```

### æ¶ˆæ¯ç±»å‹

**chunk_update** - åˆ†å—æ›´æ–°ï¼š

```json
{
  "type": "chunk_update",
  "chunkIndex": 0,
  "data": {
    "status": "processing | completed | error",
    "translatedText": "ç¿»è¯‘å†…å®¹..."
  }
}
```

**complete** - ç¿»è¯‘å®Œæˆï¼š

```json
{
  "type": "complete"
}
```

---

## å­˜å‚¨å±‚

### æ•°æ®åº“è¡¨ç»“æ„

**documents è¡¨ï¼š**

```sql
CREATE TABLE IF NOT EXISTS documents (
    id TEXT PRIMARY KEY,
    title TEXT,
    original_content TEXT,
    translated_content TEXT DEFAULT '',
    chunks_data TEXT DEFAULT '[]',
    status TEXT DEFAULT 'pending',
    created_at TEXT,
    updated_at TEXT
);

CREATE INDEX IF NOT EXISTS idx_documents_updated_at 
ON documents(updated_at DESC);
```

**settings è¡¨ï¼š**

```sql
CREATE TABLE IF NOT EXISTS settings (
    key TEXT PRIMARY KEY,
    value TEXT
);
```

---

## é…ç½®ç®¡ç†

### ç¯å¢ƒå˜é‡

åœ¨é¡¹ç›®æ ¹ç›®å½•åˆ›å»º `.env` æ–‡ä»¶ï¼š

```env
# LLM é…ç½®
QWEN_API_KEY=your_api_key_here
QWEN_API_URL=https://dashscope.aliyuncs.com/compatible-mode/v1
QWEN_MODEL_NAME=qwen-flash
```

### æ”¯æŒçš„é…ç½®é¡¹

| å˜é‡ | è¯´æ˜ | é»˜è®¤å€¼ |
|:---|:---|:---|
| `QWEN_API_KEY` | API å¯†é’¥ | - |
| `QWEN_API_URL` | API åœ°å€ | `https://dashscope.aliyuncs.com/compatible-mode/v1` |
| `QWEN_MODEL_NAME` | æ¨¡å‹åç§° | `qwen-flash` |

---

## å¼€å‘æŒ‡å—

### æ·»åŠ æ–°è·¯ç”±

1. åˆ›å»ºè·¯ç”±æ–‡ä»¶ï¼š

```python
# backend/routers/my_router.py
from fastapi import APIRouter

router = APIRouter()

@router.get("/api/my-endpoint")
async def my_endpoint():
    return {"message": "Hello"}
```

2. åœ¨ `main.py` ä¸­æ³¨å†Œï¼š

```python
# backend/main.py
from routers import translate, my_router

app.include_router(translate.router)
app.include_router(my_router.router)
```

### æ·»åŠ æ–°çš„æ•°æ®åº“æ–¹æ³•

åœ¨ `persistent_storage.py` ä¸­æ·»åŠ ï¼š

```python
async def my_new_method(self, param: str) -> Optional[Dict]:
    """æ–°çš„æ•°æ®åº“æ“ä½œ"""
    async with self._get_connection() as conn:
        conn.row_factory = aiosqlite.Row
        await self._ensure_initialized(conn)
        # æ‰§è¡Œ SQL æ“ä½œ
        cursor = await conn.execute("SELECT * FROM ...", (param,))
        row = await cursor.fetchone()
        return dict(row) if row else None
```

### è°ƒè¯•æŠ€å·§

1. **å¯åŠ¨è°ƒè¯•æ¨¡å¼**ï¼š

```bash
uvicorn main:app --reload --log-level debug
```

2. **æŸ¥çœ‹ API æ–‡æ¡£**ï¼š

è®¿é—® `http://127.0.0.1:8000/docs` æŸ¥çœ‹è‡ªåŠ¨ç”Ÿæˆçš„ Swagger æ–‡æ¡£ã€‚

3. **æ£€æŸ¥æ•°æ®åº“**ï¼š

```bash
sqlite3 backend/data/mdtranslator.db
.tables
SELECT * FROM documents;
```

### å¸¸è§é—®é¢˜

**Q: å¯¼å…¥é”™è¯¯ `ImportError: attempted relative import`**

A: ä½¿ç”¨ç»å¯¹å¯¼å…¥è€Œä¸æ˜¯ç›¸å¯¹å¯¼å…¥ï¼š

```python
# âŒ é”™è¯¯
from .persistent_storage import store

# âœ… æ­£ç¡®
from persistent_storage import store
```

**Q: aiosqlite æŠ¥é”™ "threads can only be started once"**

A: ä¸è¦ç¼“å­˜è¿æ¥å¯¹è±¡ï¼Œæ¯æ¬¡æ“ä½œéƒ½è·å–æ–°è¿æ¥ï¼š

```python
# âŒ é”™è¯¯ï¼šç¼“å­˜è¿æ¥
self._conn = await aiosqlite.connect(DB_PATH)

# âœ… æ­£ç¡®ï¼šæ¯æ¬¡æ–°å»ºè¿æ¥
async with aiosqlite.connect(DB_PATH) as conn:
    # æ“ä½œ...
```

---

## ä¸‹ä¸€æ­¥

- ğŸ”„ [æ•°æ®æµè®¾è®¡](./05-æ•°æ®æµè®¾è®¡.md) - äº†è§£å®Œæ•´æ•°æ®æµ
- ğŸ“¡ [API å‚è€ƒ](./06-APIå‚è€ƒ.md) - å®Œæ•´ API æ–‡æ¡£
- ğŸ› ï¸ [äºŒæ¬¡å¼€å‘](./07-äºŒæ¬¡å¼€å‘.md) - æ‰©å±•æŒ‡å—
